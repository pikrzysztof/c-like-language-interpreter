-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Pargramatyka where
import Absgramatyka
import Lexgramatyka
import ErrM

}

%name pListIdent ListIdent
%name pListCharOrMinus ListCharOrMinus
%name pCharOrMinus CharOrMinus
%name pComplexCoord ComplexCoord
%name pConst Const
%name pListExpr0 ListExpr0
%name pExpr0 Expr0
%name pExpr11 Expr11
%name pExpr1 Expr1
%name pExpr2 Expr2
%name pExpr3 Expr3
%name pExpr4 Expr4
%name pExpr5 Expr5
%name pExpr6 Expr6
%name pExpr7 Expr7
%name pExpr8 Expr8
%name pExpr9 Expr9
%name pExpr10 Expr10
%name pOption Option
%name pListStmt ListStmt
%name pStmt Stmt
%name pFanoutSugarOp FanoutSugarOp
%name pType Type
%name pConstDef ConstDef
%name pVarDef VarDef
%name pListArgDef ListArgDef
%name pArgDef ArgDef
%name pListConstOrVar ListConstOrVar
%name pConstOrVar ConstOrVar
%name pBody Body
%name pDef Def
%name pBlock Block

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '#' { PT _ (TS _ 3) }
  '&' { PT _ (TS _ 4) }
  '(' { PT _ (TS _ 5) }
  ')' { PT _ (TS _ 6) }
  '*' { PT _ (TS _ 7) }
  '+' { PT _ (TS _ 8) }
  ',' { PT _ (TS _ 9) }
  '-' { PT _ (TS _ 10) }
  '->' { PT _ (TS _ 11) }
  '/' { PT _ (TS _ 12) }
  ';' { PT _ (TS _ 13) }
  '<' { PT _ (TS _ 14) }
  '<-' { PT _ (TS _ 15) }
  '<=' { PT _ (TS _ 16) }
  '=' { PT _ (TS _ 17) }
  '==' { PT _ (TS _ 18) }
  '>' { PT _ (TS _ 19) }
  '>=' { PT _ (TS _ 20) }
  'Const' { PT _ (TS _ 21) }
  '^' { PT _ (TS _ 22) }
  'and' { PT _ (TS _ 23) }
  'complex' { PT _ (TS _ 24) }
  'dump' { PT _ (TS _ 25) }
  'else' { PT _ (TS _ 26) }
  'exit' { PT _ (TS _ 27) }
  'extern' { PT _ (TS _ 28) }
  'false' { PT _ (TS _ 29) }
  'for' { PT _ (TS _ 30) }
  'if' { PT _ (TS _ 31) }
  'input' { PT _ (TS _ 32) }
  'int' { PT _ (TS _ 33) }
  'list' { PT _ (TS _ 34) }
  'load' { PT _ (TS _ 35) }
  'measure' { PT _ (TS _ 36) }
  'mod' { PT _ (TS _ 37) }
  'not' { PT _ (TS _ 38) }
  'operator' { PT _ (TS _ 39) }
  'or' { PT _ (TS _ 40) }
  'print' { PT _ (TS _ 41) }
  'procedure' { PT _ (TS _ 42) }
  'quConst' { PT _ (TS _ 43) }
  'qufunct' { PT _ (TS _ 44) }
  'qureg' { PT _ (TS _ 45) }
  'quscratch' { PT _ (TS _ 46) }
  'quvoid' { PT _ (TS _ 47) }
  'real' { PT _ (TS _ 48) }
  'reset' { PT _ (TS _ 49) }
  'return' { PT _ (TS _ 50) }
  'save' { PT _ (TS _ 51) }
  'set' { PT _ (TS _ 52) }
  'shell' { PT _ (TS _ 53) }
  'step' { PT _ (TS _ 54) }
  'string' { PT _ (TS _ 55) }
  'to' { PT _ (TS _ 56) }
  'true' { PT _ (TS _ 57) }
  'until' { PT _ (TS _ 58) }
  'while' { PT _ (TS _ 59) }
  'xor' { PT _ (TS _ 60) }
  '{' { PT _ (TS _ 61) }
  '}' { PT _ (TS _ 62) }

L_ident  { PT _ (TV $$) }
L_charac { PT _ (TC $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_quoted { PT _ (TL $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
String  :: { String }  : L_quoted {  $1 }

ListIdent :: { [Ident] }
ListIdent : {- empty -} { [] } 
  | Ident { (:[]) $1 }
  | Ident ',' ListIdent { (:) $1 $3 }
  | {- empty -} { [] }
  | Ident ListIdent { (:) $1 $2 }


ListCharOrMinus :: { [CharOrMinus] }
ListCharOrMinus : {- empty -} { [] } 
  | CharOrMinus ListCharOrMinus { (:) $1 $2 }
  | {- empty -} { [] }
  | CharOrMinus ListCharOrMinus { (:) $1 $2 }


CharOrMinus :: { CharOrMinus }
CharOrMinus : Char { CharM $1 } 
  | '-' { MinusM }


ComplexCoord :: { ComplexCoord }
ComplexCoord : Integer { ComplexCoordInt $1 } 
  | Double { ComplexCoordDouble $1 }


Const :: { Const }
Const : ComplexCoord { CJustConst $1 } 
  | '(' ComplexCoord ',' ComplexCoord ')' { CConstComplexPair $2 $4 }
  | 'true' { CBoolTrue }
  | 'false' { CBoolFalse }
  | String { CString $1 }


ListExpr0 :: { [Expr] }
ListExpr0 : {- empty -} { [] } 
  | Expr0 { (:[]) $1 }
  | Expr0 ',' ListExpr0 { (:) $1 $3 }
  | {- empty -} { [] }
  | Expr0 ListExpr0 { (:) $1 $2 }


Expr0 :: { Expr }
Expr0 : Ident '(' ListExpr0 ')' { EFCall $1 $3 } 
  | Expr0 '==' Expr1 { EEq $1 $3 }
  | Expr0 '!=' Expr1 { ENeq $1 $3 }


Expr11 :: { Expr }
Expr11 : Const { EConst $1 } 


Expr1 :: { Expr }
Expr1 : Expr1 '<' Expr2 { ELe $1 $3 } 
  | Expr1 '<=' Expr2 { ELEq $1 $3 }
  | Expr1 '>' Expr2 { EGr $1 $3 }
  | Expr1 '>=' Expr2 { EGrEq $1 $3 }


Expr2 :: { Expr }
Expr2 : Expr2 'or' Expr3 { EOr $1 $3 } 


Expr3 :: { Expr }
Expr3 : Expr3 'and' Expr4 { EAnd $1 $3 } 


Expr4 :: { Expr }
Expr4 : Expr4 'xor' Expr5 { EXor $1 $3 } 


Expr5 :: { Expr }
Expr5 : 'not' Expr6 { ENot $2 } 


Expr6 :: { Expr }
Expr6 : Expr6 '+' Expr7 { EAdd $1 $3 } 
  | Expr6 '-' Expr7 { ESubtract $1 $3 }
  | Expr6 '&' Expr7 { EStringConcat $1 $3 }


Expr7 :: { Expr }
Expr7 : Expr7 '*' Expr8 { ETimes $1 $3 } 
  | Expr7 '/' Expr8 { EDiv $1 $3 }
  | Expr7 'mod' Expr8 { EMod $1 $3 }


Expr8 :: { Expr }
Expr8 : Expr8 '^' Expr9 { EPow $1 $3 } 


Expr9 :: { Expr }
Expr9 : '-' Expr10 { EUnaryMinus $2 } 


Expr10 :: { Expr }
Expr10 : '#' Expr11 { ESize $2 } 
  | '(' Expr0 ')' { $2 }


Option :: { Option }
Option : Char ListCharOrMinus { JustOption $1 $2 } 


ListStmt :: { [Stmt] }
ListStmt : {- empty -} { [] } 
  | Stmt ListStmt { (:) $1 $2 }
  | {- empty -} { [] }
  | Stmt ListStmt { (:) $1 $2 }


Stmt :: { Stmt }
Stmt : '!' Ident '(' ')' ';' { UnitaryOpInvCall $2 } 
  | '!' Ident '(' ListExpr0 ')' ';' { UnitaryOpArgInvCall $2 $4 }
  | Ident '=' Expr0 ';' { Assignment $1 $3 }
  | Expr0 FanoutSugarOp Expr0 { FanoutSugar $1 $2 $3 }
  | 'for' Ident '=' Expr0 'to' Expr0 Block { ForLoop $2 $4 $6 $7 }
  | 'for' Ident '=' Expr0 'to' Expr0 'step' Expr0 Block { ForStepLoop $2 $4 $6 $8 $9 }
  | 'while' Expr0 Block { WhileLoop $2 $3 }
  | Block 'until' Expr0 ';' { UntilLoop $1 $3 }
  | 'if' Expr0 Block { ConditionalBranch $2 $3 }
  | 'if' Expr0 Block 'else' Block { ConditionalBranchElse $2 $3 $5 }
  | 'return' Expr0 ';' { ReturnExpr $2 }
  | 'input' Expr0 Ident ';' { InputExpr $2 $3 }
  | 'input' Ident ';' { InputNoExpr $2 }
  | 'print' ListExpr0 ';' { Print $2 }
  | 'exit' Expr0 ';' { Exit $2 }
  | 'measure' Expr0 ';' { MeasureNoIdent $2 }
  | 'measure' Expr0 ',' Ident ';' { MeasureIdent $2 $4 }
  | 'reset' ';' { Reset }
  | 'list' ListIdent ';' { List $2 }
  | 'dump' Expr0 ';' { DumpExpr $2 }
  | 'dump' ';' { DumpNoExpr }
  | 'load' Expr0 ';' { LoadExpr $2 }
  | 'load' ';' { LoadNoExpr }
  | 'save' Expr0 ';' { SaveExpr $2 }
  | 'save' ';' { SaveNoExpr }
  | 'shell' ';' { Shell }
  | 'set' Option ',' Expr0 ';' { SetExpr $2 $4 }
  | 'set' Option ';' { SetNoExpr $2 }
  | Stmt ';' { StmtSemicolon $1 }


FanoutSugarOp :: { FanoutSugarOp }
FanoutSugarOp : '->' { FanoutRight } 
  | '<-' { FanoutLeft }
  | '<-' { FanoutSwap }


Type :: { Type }
Type : 'int' { TInt } 
  | 'real' { TReal }
  | 'complex' { TComplex }
  | 'string' { TString }
  | 'qureg' { TQureg }
  | 'quvoid' { TQuvoid }
  | 'quConst' { TQuConst }
  | 'quscratch' { TQuscratch }


ConstDef :: { ConstDef }
ConstDef : 'Const' Ident '=' Expr0 ';' { JustConstDef $2 $4 } 


VarDef :: { VarDef }
VarDef : Type Ident ';' { JustVarDef $1 $2 } 
  | Type Ident '=' Expr0 ';' { VarDefAss $1 $2 $4 }
  | Type Ident Expr0 ';' { VarDefExpr $1 $2 $3 }


ListArgDef :: { [ArgDef] }
ListArgDef : {- empty -} { [] } 
  | ArgDef { (:[]) $1 }
  | ArgDef ',' ListArgDef { (:) $1 $3 }
  | {- empty -} { [] }
  | ArgDef ListArgDef { (:) $1 $2 }


ArgDef :: { ArgDef }
ArgDef : Type Ident { JustArgDef $1 $2 } 


ListConstOrVar :: { [ConstOrVar] }
ListConstOrVar : {- empty -} { [] } 
  | ConstOrVar ListConstOrVar { (:) $1 $2 }
  | {- empty -} { [] }
  | ConstOrVar ListConstOrVar { (:) $1 $2 }


ConstOrVar :: { ConstOrVar }
ConstOrVar : ConstDef { ConstDefList $1 } 
  | VarDef { VarDefList $1 }


Body :: { Body }
Body : '{' ListConstOrVar ListStmt '}' { JustBody $2 $3 } 


Def :: { Def }
Def : ConstDef { DefConstDef $1 } 
  | VarDef { VarDefDef $1 }
  | Type Ident '(' ListArgDef ')' Body { FunDef $1 $2 $4 $6 }
  | 'procedure' Ident '(' ListArgDef ')' Body { ProcDef $2 $4 $6 }
  | 'operator' Ident '(' ListArgDef ')' Body { OperatorDef $2 $4 $6 }
  | 'qufunct' Ident '(' ListArgDef ')' Body { QufunctDef $2 $4 $6 }
  | 'extern' 'operator' Ident '(' ListArgDef ')' ';' { ExternOpDef $3 $5 }
  | 'extern' 'qufunct' Ident '(' ListArgDef ')' ';' { ExternQufunctDef $3 $5 }


Block :: { Block }
Block : '{' ListStmt '}' { JustBlock $2 } 



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

