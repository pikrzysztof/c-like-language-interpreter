module Skelgramatyka where

-- Haskell module generated by the BNF converter

import Absgramatyka
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> Result
transIdent x = case x of
  Ident str  -> failure x


transCharOrMinus :: CharOrMinus -> Result
transCharOrMinus x = case x of
  CharM c  -> failure x
  MinusM  -> failure x


transComplexCoord :: ComplexCoord -> Result
transComplexCoord x = case x of
  ComplexCoordInt n  -> failure x
  ComplexCoordDouble d  -> failure x


transConst :: Const -> Result
transConst x = case x of
  CJustConst complexcoord  -> failure x
  CConstComplexPair complexcoord1 complexcoord2  -> failure x
  CBoolTrue  -> failure x
  CBoolFalse  -> failure x
  CString str  -> failure x


transOption :: Option -> Result
transOption x = case x of
  JustOption c charorminuss  -> failure x


transStmt :: Stmt -> Result
transStmt x = case x of
  UnitaryOpInvCall id  -> failure x
  UnitaryOpArgInvCall id exprs  -> failure x
  Assignment id expr  -> failure x
  FanoutSugar expr1 fanoutsugarop2 expr3  -> failure x
  ForLoop id expr1 expr2 block3  -> failure x
  ForStepLoop id expr1 expr2 expr3 block4  -> failure x
  WhileLoop expr block  -> failure x
  UntilLoop block expr  -> failure x
  ConditionalBranch expr block  -> failure x
  ConditionalBranchElse expr block1 block2  -> failure x
  ReturnExpr expr  -> failure x
  InputExpr expr id  -> failure x
  InputNoExpr id  -> failure x
  Print exprs  -> failure x
  Exit expr  -> failure x
  MeasureNoIdent expr  -> failure x
  MeasureIdent expr id  -> failure x
  Reset  -> failure x
  List ids  -> failure x
  DumpExpr expr  -> failure x
  DumpNoExpr  -> failure x
  LoadExpr expr  -> failure x
  LoadNoExpr  -> failure x
  SaveExpr expr  -> failure x
  SaveNoExpr  -> failure x
  Shell  -> failure x
  SetExpr option expr  -> failure x
  SetNoExpr option  -> failure x
  StmtSemicolon stmt  -> failure x


transFanoutSugarOp :: FanoutSugarOp -> Result
transFanoutSugarOp x = case x of
  FanoutRight  -> failure x
  FanoutLeft  -> failure x
  FanoutSwap  -> failure x


transType :: Type -> Result
transType x = case x of
  TInt  -> failure x
  TReal  -> failure x
  TComplex  -> failure x
  TString  -> failure x
  TQureg  -> failure x
  TQuvoid  -> failure x
  TQuConst  -> failure x
  TQuscratch  -> failure x


transConstDef :: ConstDef -> Result
transConstDef x = case x of
  JustConstDef id expr  -> failure x


transVarDef :: VarDef -> Result
transVarDef x = case x of
  JustVarDef type' id  -> failure x
  VarDefAss type' id expr  -> failure x
  VarDefExpr type' id expr  -> failure x


transArgDef :: ArgDef -> Result
transArgDef x = case x of
  JustArgDef type' id  -> failure x


transConstOrVar :: ConstOrVar -> Result
transConstOrVar x = case x of
  ConstDefList constdef  -> failure x
  VarDefList vardef  -> failure x


transBody :: Body -> Result
transBody x = case x of
  JustBody constorvars stmts  -> failure x


transDef :: Def -> Result
transDef x = case x of
  DefConstDef constdef  -> failure x
  VarDefDef vardef  -> failure x
  FunDef type' id argdefs body  -> failure x
  ProcDef id argdefs body  -> failure x
  OperatorDef id argdefs body  -> failure x
  QufunctDef id argdefs body  -> failure x
  ExternOpDef id argdefs  -> failure x
  ExternQufunctDef id argdefs  -> failure x


transBlock :: Block -> Result
transBlock x = case x of
  JustBlock stmts  -> failure x



