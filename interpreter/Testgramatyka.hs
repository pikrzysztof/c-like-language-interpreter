-- automatically generated by BNF Converter
module Main where


import System.IO ( stdin, hGetContents )
import System.Environment ( getArgs, getProgName )
import System.Exit ( exitFailure, exitSuccess )

import Lexgramatyka
import Pargramatyka
import Skelgramatyka
import Printgramatyka
import Absgramatyka
import ErrM
import Data.Void as Void
import Data.Map
import Data.Complex as Complex
import Control.Monad.Except
import Control.Monad.Reader
import Control.Monad.State
type ParseFun a = [Token] -> Err a
myLLexer = myLexer
type Verbosity = Int
-- koniec definicji magicznego generatora parserow

data Stan = Stan { stan :: Data.Map.Map Ident Loc
                 }

data Srodowisko = Srod { srod :: Data.Map.Map Ident MyType
                       }

type Przetwarzacz a = ExceptT String (ReaderT Srodowisko (StateT Stan IO)) a
                  -- b  = ExceptT
                    --    (StateT Stan
                    --     (ReaderT Srodowisko
                    --      (IO (Either String a))) b)


type Loc = Int                  -- lokacja
data MyType = String
            | Num
            | Bool
            | Complex
            | Void
              deriving (Eq, Ord, Show, Read)




putStrV :: Verbosity -> String -> IO ()
putStrV v s = if v > 1 then putStrLn s else return ()

runFile :: Verbosity -> ParseFun Program -> FilePath -> IO ()
runFile v p f = putStrLn f >> readFile f >>= run v p

run :: Verbosity -> ParseFun Program -> String -> IO ()
run v p s = let ts = myLLexer s in case  p ts of
           Bad s    -> do putStrLn s
                          exitFailure
           Ok  tree -> do putStrLn "\nParse Successful!"
-- tree to tak wlasciwie QCLProgram [Def] [Stmt]
                          Main.showTree v tree
                          exitSuccess


showTree :: (Show a, Print a) => Int -> a -> IO ()
showTree v tree
 = do
      putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
      putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree

main :: IO ()
main = do args <- getArgs
          case args of
            [] -> hGetContents stdin >>= run 2 pProgram
            "-s":fs -> mapM_ (runFile 0 pProgram) fs
            fs -> mapM_ (runFile 2 pProgram) fs

-- typeCheck :: Err Program -> ExceptT Program
typeCheck = undefined
