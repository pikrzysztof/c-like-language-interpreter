-- automatically generated by BNF Converter
module Main where


import System.IO ( stdin, hGetContents )
import System.Environment ( getArgs, getProgName )
import System.Exit ( exitFailure, exitSuccess )

import Lexgramatyka
import Pargramatyka
import Skelgramatyka
import Printgramatyka
import Absgramatyka
import ErrM

import Control.Monad.Except
import Control.Monad.RWS
import qualified Srodowisko as Sr
import qualified Stan as St

type ParseFun a = [Token] -> Err a
myLLexer = myLexer
type Verbosity = Int
-- koniec zmudnych definicji





type Przetwarzacz a = ExceptT String (RWST Sr.Srodowisko () St.Stan IO) a


putStrV :: Verbosity -> String -> IO ()
putStrV v s = if v > 1 then putStrLn s else return ()

runFile :: Verbosity -> ParseFun Program -> FilePath -> IO ()
runFile v p f = putStrLn f >> readFile f >>= run v p

run :: Verbosity -> ParseFun Program -> String -> IO ()
run v p s = let ts = myLLexer s in case  p ts of
           Bad s    -> do putStrLn s
                          exitFailure
           Ok  tree -> do runRWST ( runExceptT $ zinterpretuj tree)
                            Sr.srodowiskoZero St.stanZero
                          exitSuccess


showTree :: (Show a, Print a) => Int -> a -> IO ()
showTree v tree
 = do
      putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
      putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree

main :: IO ()
main = do args <- getArgs
          case args of
            [] -> hGetContents stdin >>= run 2 pProgram
            "-s":fs -> mapM_ (runFile 0 pProgram) fs
            fs -> mapM_ (runFile 2 pProgram) fs

oblicz_wyrazenie :: Expr -> Przetwarzacz St.TypQCL
oblicz_wyrazenie e = do
  case e of
   Variable id ->
     return undefined
   EFCall id [expr] ->
     return undefined
   ETableElement id [expr] ->
     return undefined
   EListaOdDo id expr1 expr2 ->
     return undefined
   ELiczbaElementowListy id expr1 expr2 -> -- x[z::y]
     return undefined
   ETrzecieListy id expr1 expr2 ->         -- x[z..y]
     return undefined
   EListyBez id expr1 expr2 ->           -- x[z\y]
     return undefined
   EConst (CJustConst cc) ->                          -- const
     return undefined
   EEq expr1 expr2 ->                       -- x == z
     return undefined
   ENeq expr1 expr2 ->                      -- x != z
     return undefined
   ELe expr1 expr2 ->                       -- x < y
     return undefined
   ELEq expr1 expr2 ->                      -- x <= y
     return undefined
   EGr expr1 expr2 ->                       -- x > y
     return undefined
   EGrEq expr1 expr2 ->                     -- x >= y
     return undefined
   EOr expr1 expr2 ->                       -- x or y
     return undefined
   EAnd expr1 expr2 ->                      -- x and y
     return undefined
   EXor expr1 expr2 ->                      -- x xor y
     return undefined
   ENot expr ->                           -- not y
     return undefined
   EAdd expr1 expr2 ->                      -- x + y
     return undefined
   ESubtract expr1 expr2 ->                 -- x - y
     return undefined
   EStringConcat expr1 expr2 ->             -- x & y
     return undefined
   ETimes expr1 expr2 ->                    -- x * y
     return undefined
   EDiv expr1 expr2 ->                      -- x / y
     return undefined
   EMod expr1 expr2 ->                      -- x mod y
     return undefined
   EPow expr1 expr2 ->                      -- x ^ y
     return undefined
   EUnaryMinus expr ->                    -- -x
     return undefined
   ESize expr ->                          -- #x
     return undefined

wloz_def :: Ident -> St.TypQCL -> Przetwarzacz Sr.Srodowisko
wloz_def id wartosc = do
  lok <- gets St.daj_wolna_lok
  modify St.zwieksz_wolna_lok
  modify $ St.dodaj_wartosc lok wartosc
  srod <- ask
  return $ Sr.zmien_srodowisko id lok srod

oblicz_def :: Def -> Przetwarzacz Sr.Srodowisko
oblicz_def def = do
  case def of
   DefConstDef (ClassicalConstDef id expr) -> do
     ile <- oblicz_wyrazenie expr
     wynik <- wloz_def id ile
     return wynik
   DefConstDef (QuantumConstDef typ id) -> do
     return undefined
   VarDefDef (JustVarDef typ id) -> do
     wynik <- wloz_def id undefined
     return wynik
   VarDefDef (VarDefAss typ id expr) -> do
     ile <- oblicz_wyrazenie expr
     wynik <- wloz_def id ile
     return wynik
   VarDefDef (VarDefTable typ id expr) -> do
     return undefined
   FunDef typ id argy cialo -> do
     return undefined
   ProcDef id argy cialo -> do
     return undefined
   OperatorDef id argy cialo -> do
     return undefined
   QufunctOperatorDef id argy cialo -> do
     return undefined
   CondOperatorDef id argy cialo -> do
     return undefined
   QufunctDef id argy cialo -> do
     return undefined
   CondQufunctDef id argy cialo -> do
     return undefined
   ExternOpDef id argy -> do
     return undefined
   ExternQufunctDef id argy -> do
     return undefined
   ExternCondOpDef id argy -> do
     return undefined
   ExternCondQufunctDef id argy -> do
     return undefined

zinterpretuj :: Program -> Przetwarzacz ()
zinterpretuj (QCLProgram decl stmt) = undefined


  -- local (zarejestruj_deklaracje def1) $ zinterpretuj defs stmt
  -- where
  --   zarejestruj_deklaracje :: Def -> Srodowisko -> Srodowisko
  --   zarejestruj_deklaracje def1 =
  --     case def1 of
  --      DefConstDef constDef -> case constDef of
  --                               ClassicalConstDef id expr = zarezerwuj
  --      ExternOpDef ident argef -> undefined
  --      ExternQufunctDef id arged -> undefined
  --      ExternCondOpDef id argdef -> undefined
  --      ExternCondQufunctDef id argdef -> undefined










-- zinterpretujDef :: [Def] -> Przetwarzacz ()
-- zinterpretujDef (DefConstDef cd) = case cd of
--   ClassicalConstDef id expr -> do
--     sprawdz_unikalnosc id
--     case DefConstDef of
--      modify


zinterpretujStmt :: [Stmt] -> Przetwarzacz ()
zinterpretujStmt = undefined
