-- automatically generated by BNF Converter
module Main where

import System.IO ( stdin, stderr, hPutStrLn, hGetContents )
import System.Environment ( getArgs)
import System.Exit ( exitFailure, exitSuccess)
import qualified Lexgramatyka
import qualified Pargramatyka
import qualified Printgramatyka
import Absgramatyka
import ErrM

import Control.Monad.Except
import Control.Monad.RWS
import Control.Monad.Reader
import qualified Srodowisko as Sr
import qualified Stan as St
import InterpreterAbsgramatyki
import TypyZalezne

import SprawdzaczTypow
type ParseFun a = [Lexgramatyka.Token] -> Err a
myLLexer :: String -> [Lexgramatyka.Token]
myLLexer = Pargramatyka.myLexer
type Verbosity = Int
-- koniec zmudnych definicji


putStrV :: Verbosity -> String -> IO ()
putStrV v s = if v > 1 then putStrLn s else return ()


runFile :: Verbosity -> ParseFun Program -> FilePath -> IO ()
runFile v p f = putStrLn f >> readFile f >>= run v p

run :: Verbosity -> ParseFun Program -> String -> IO ()
run _ p s = let ts = myLLexer s in case  p ts of
           Bad e -> do
             putStrLn e
             exitFailure
           Ok tree -> do
             _ <- runReaderT (runExceptT $ sprawdz_typy tree) Sr.srodowiskoZero
             _ <- runRWST ( runExceptT $ zinterpretuj tree)
               Sr.srodowiskoZero St.stanZero
             exitSuccess


showTree :: (Show a, Printgramatyka.Print a) => Int -> a -> IO ()
showTree v tree  = do
      putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
      putStrV v $ "\n[Linearized tree]\n\n" ++ Printgramatyka.printTree tree

main :: IO ()
main = do args <- getArgs
          case args of
            [] -> hGetContents stdin >>= run 2 Pargramatyka.pProgram
            "-s":fs -> mapM_ (runFile 0 Pargramatyka.pProgram) fs
            fs -> mapM_ (runFile 2 Pargramatyka.pProgram) fs


zinterpretuj :: Program -> Przetwarzacz ()
zinterpretuj (QCLProgram (def:resztadef) stmt) = do {
  sr <- oblicz_def def;
  local (const sr) (zinterpretuj (QCLProgram resztadef stmt));
  } `catchError` zlap_wyjatek

zinterpretuj (QCLProgram [] (stmt:stmt2)) = do {
  zinterpretuj_stmt stmt;
  zinterpretuj (QCLProgram [] stmt2);
  } `catchError` zlap_wyjatek

zinterpretuj (QCLProgram [] []) = do {
  srod <- ask;
  stan <- get;
  lift $ lift $ hPutStrLn stderr "Koniec.";
  lift $ lift $ hPutStrLn stderr $ "STAN " ++ (show stan);
  lift $ lift $ hPutStrLn stderr $ "SRODOWISKO " ++ show (srod);
  return ()
  } `catchError` zlap_wyjatek


zlap_wyjatek :: String -> Przetwarzacz () -- ExceptT String (RWST (Sr.Srodowisko Loc) () St.Stan IO) ()
zlap_wyjatek x = do
  lift $ lift $ putStrLn ("BLAD " ++ x)
  srod <- ask
  stan <- get
  lift $ lift $ hPutStrLn stderr ("SRODOWISKO " ++ (show srod) ++ "\nSTAN " ++ (show stan))
