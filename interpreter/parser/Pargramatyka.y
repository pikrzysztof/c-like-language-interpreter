-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Pargramatyka where
import Absgramatyka
import Lexgramatyka
import ErrM

}

%name pProgram Program

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '#' { PT _ (TS _ 3) }
  '&' { PT _ (TS _ 4) }
  '(' { PT _ (TS _ 5) }
  ')' { PT _ (TS _ 6) }
  '*' { PT _ (TS _ 7) }
  '+' { PT _ (TS _ 8) }
  ',' { PT _ (TS _ 9) }
  '-' { PT _ (TS _ 10) }
  '->' { PT _ (TS _ 11) }
  '..' { PT _ (TS _ 12) }
  '/' { PT _ (TS _ 13) }
  ':' { PT _ (TS _ 14) }
  '::' { PT _ (TS _ 15) }
  ';' { PT _ (TS _ 16) }
  '<' { PT _ (TS _ 17) }
  '<-' { PT _ (TS _ 18) }
  '<->' { PT _ (TS _ 19) }
  '<=' { PT _ (TS _ 20) }
  '=' { PT _ (TS _ 21) }
  '==' { PT _ (TS _ 22) }
  '>' { PT _ (TS _ 23) }
  '>=' { PT _ (TS _ 24) }
  '[' { PT _ (TS _ 25) }
  '\\' { PT _ (TS _ 26) }
  ']' { PT _ (TS _ 27) }
  '^' { PT _ (TS _ 28) }
  'and' { PT _ (TS _ 29) }
  'boolean' { PT _ (TS _ 30) }
  'complex' { PT _ (TS _ 31) }
  'cond' { PT _ (TS _ 32) }
  'const' { PT _ (TS _ 33) }
  'dump' { PT _ (TS _ 34) }
  'else' { PT _ (TS _ 35) }
  'exit' { PT _ (TS _ 36) }
  'extern' { PT _ (TS _ 37) }
  'false' { PT _ (TS _ 38) }
  'for' { PT _ (TS _ 39) }
  'if' { PT _ (TS _ 40) }
  'input' { PT _ (TS _ 41) }
  'int' { PT _ (TS _ 42) }
  'list' { PT _ (TS _ 43) }
  'load' { PT _ (TS _ 44) }
  'matrix' { PT _ (TS _ 45) }
  'measure' { PT _ (TS _ 46) }
  'mod' { PT _ (TS _ 47) }
  'not' { PT _ (TS _ 48) }
  'operator' { PT _ (TS _ 49) }
  'or' { PT _ (TS _ 50) }
  'print' { PT _ (TS _ 51) }
  'procedure' { PT _ (TS _ 52) }
  'qucond' { PT _ (TS _ 53) }
  'quconst' { PT _ (TS _ 54) }
  'qufunct' { PT _ (TS _ 55) }
  'qureg' { PT _ (TS _ 56) }
  'quscratch' { PT _ (TS _ 57) }
  'quvoid' { PT _ (TS _ 58) }
  'real' { PT _ (TS _ 59) }
  'reset' { PT _ (TS _ 60) }
  'return' { PT _ (TS _ 61) }
  'save' { PT _ (TS _ 62) }
  'set' { PT _ (TS _ 63) }
  'shell' { PT _ (TS _ 64) }
  'step' { PT _ (TS _ 65) }
  'string' { PT _ (TS _ 66) }
  'tensor' { PT _ (TS _ 67) }
  'to' { PT _ (TS _ 68) }
  'true' { PT _ (TS _ 69) }
  'until' { PT _ (TS _ 70) }
  'vector' { PT _ (TS _ 71) }
  'while' { PT _ (TS _ 72) }
  'xor' { PT _ (TS _ 73) }
  '{' { PT _ (TS _ 74) }
  '}' { PT _ (TS _ 75) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_quoted { PT _ (TL $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
String  :: { String }  : L_quoted {  $1 }

Program :: { Program }
Program : ListDef ListStmt { QCLProgram (reverse $1) (reverse $2) } 


ListIdent :: { [Ident] }
ListIdent : {- empty -} { [] } 
  | Ident { (:[]) $1 }
  | Ident ',' ListIdent { (:) $1 $3 }


Const :: { Const }
Const : Integer { CJustConst $1 } 
  | '(' Integer ',' Integer ')' { CConstComplexPair $2 $4 }
  | 'true' { CBoolTrue }
  | 'false' { CBoolFalse }
  | String { CString $1 }


ListExpr :: { [Expr] }
ListExpr : {- empty -} { [] } 
  | Expr { (:[]) $1 }
  | Expr ',' ListExpr { (:) $1 $3 }


Expr11 :: { Expr }
Expr11 : Ident { Variable $1 } 
  | Ident '(' ListExpr ')' { EFCall $1 $3 }
  | Ident '[' Expr ']' { ETableElement $1 $3 }
  | Ident '[' Expr ',' Expr ']' { EMatrixElement $1 $3 $5 }
  | Ident '[' Expr ':' Expr ']' { EListaOdDo $1 $3 $5 }
  | Ident '[' Expr '::' Expr ']' { ELiczbaElementowListy $1 $3 $5 }
  | Ident '[' Expr '..' Expr ']' { ETrzecieListy $1 $3 $5 }
  | Ident '[' Expr '\\' Expr ']' { EListyBez $1 $3 $5 }
  | Const { EConst $1 }
  | '(' Expr ')' { $2 }


Expr :: { Expr }
Expr : Expr '==' Expr1 { EEq $1 $3 } 
  | Expr '!=' Expr1 { ENeq $1 $3 }
  | Expr1 { $1 }


Expr1 :: { Expr }
Expr1 : Expr1 '<' Expr2 { ELe $1 $3 } 
  | Expr1 '<=' Expr2 { ELEq $1 $3 }
  | Expr1 '>' Expr2 { EGr $1 $3 }
  | Expr1 '>=' Expr2 { EGrEq $1 $3 }
  | Expr2 { $1 }


Expr2 :: { Expr }
Expr2 : Expr2 'or' Expr3 { EOr $1 $3 } 
  | Expr3 { $1 }


Expr3 :: { Expr }
Expr3 : Expr3 'and' Expr4 { EAnd $1 $3 } 
  | Expr4 { $1 }


Expr4 :: { Expr }
Expr4 : Expr4 'xor' Expr5 { EXor $1 $3 } 
  | Expr5 { $1 }


Expr5 :: { Expr }
Expr5 : 'not' Expr6 { ENot $2 } 
  | Expr6 { $1 }


Expr6 :: { Expr }
Expr6 : Expr6 '+' Expr7 { EAdd $1 $3 } 
  | Expr6 '-' Expr7 { ESubtract $1 $3 }
  | Expr6 '&' Expr7 { EStringConcat $1 $3 }
  | Expr7 { $1 }


Expr7 :: { Expr }
Expr7 : Expr7 '*' Expr8 { ETimes $1 $3 } 
  | Expr7 '/' Expr8 { EDiv $1 $3 }
  | Expr7 'mod' Expr8 { EMod $1 $3 }
  | Expr8 { $1 }


Expr8 :: { Expr }
Expr8 : Expr8 '^' Expr9 { EPow $1 $3 } 
  | Expr9 { $1 }


Expr9 :: { Expr }
Expr9 : '-' Expr10 { EUnaryMinus $2 } 
  | Expr10 { $1 }


Expr10 :: { Expr }
Expr10 : '#' Expr11 { ESize $2 } 
  | Expr11 { $1 }


Option :: { Option }
Option : Ident { JustOption $1 } 


ListStmt :: { [Stmt] }
ListStmt : {- empty -} { [] } 
  | ListStmt Stmt { flip (:) $1 $2 }


Stmt :: { Stmt }
Stmt : '!' Ident '(' ListExpr ')' ';' { UnitaryOpInvCall $2 $4 } 
  | Expr ';' { Expression $1 }
  | Expr '=' Expr ';' { Assignment $1 $3 }
  | Expr FanoutSugarOp Expr ';' { FanoutSugar $1 $2 $3 }
  | 'for' Ident '=' Expr 'to' Expr Block { ForLoop $2 $4 $6 $7 }
  | 'for' Ident '=' Expr 'to' Expr 'step' Expr Block { ForStepLoop $2 $4 $6 $8 $9 }
  | 'while' Expr Block { WhileLoop $2 $3 }
  | Block 'until' Expr ';' { UntilLoop $1 $3 }
  | 'if' Expr Block { ConditionalBranch $2 $3 }
  | 'if' Expr Block 'else' Block { ConditionalBranchElse $2 $3 $5 }
  | 'return' Expr ';' { ReturnExpr $2 }
  | 'input' Expr Ident ';' { InputExpr $2 $3 }
  | 'input' Ident ';' { InputNoExpr $2 }
  | 'print' ListExpr ';' { Print $2 }
  | 'exit' Expr ';' { Exit $2 }
  | 'measure' Expr ';' { MeasureNoIdent $2 }
  | 'measure' Expr ',' Ident ';' { MeasureIdent $2 $4 }
  | 'reset' ';' { Reset }
  | 'list' ListIdent ';' { List $2 }
  | 'dump' Expr ';' { DumpExpr $2 }
  | 'dump' ';' { DumpNoExpr }
  | 'load' Expr ';' { LoadExpr $2 }
  | 'load' ';' { LoadNoExpr }
  | 'save' Expr ';' { SaveExpr $2 }
  | 'save' ';' { SaveNoExpr }
  | 'shell' ';' { Shell }
  | 'set' Option Expr ';' { SetExpr $2 $3 }
  | ';' { Semicolon }


FanoutSugarOp :: { FanoutSugarOp }
FanoutSugarOp : '->' { FanoutRight } 
  | '<-' { FanoutLeft }
  | '<->' { FanoutSwap }


Type :: { Type }
Type : ST { SimpleType $1 } 
  | ST 'vector' { Vector $1 }
  | ST 'matrix' { Matrix $1 }
  | ST 'tensor' Integer { Tensor $1 $3 }


ST :: { ST }
ST : 'string' { TString } 
  | 'boolean' { TBoolean }
  | 'int' { TInt }
  | 'real' { TReal }
  | 'complex' { TComplex }
  | 'qureg' { TQureg }
  | 'quvoid' { TQuvoid }
  | 'quconst' { TQuConst }
  | 'quscratch' { TQuscratch }
  | 'qucond' { TQucond }


ConstDef :: { ConstDef }
ConstDef : 'const' Ident '=' Expr { ClassicalConstDef $2 $4 } 
  | Type Ident '=' 'cond' { QuantumConstDef $1 $2 }


VarDef :: { VarDef }
VarDef : Type Ident { JustVarDef $1 $2 } 
  | Type Ident '=' Expr { VarDefAss $1 $2 $4 }
  | Type Ident '[' Expr ']' { VarDefTable $1 $2 $4 }


ListArgDef :: { [ArgDef] }
ListArgDef : {- empty -} { [] } 
  | ArgDef { (:[]) $1 }
  | ArgDef ',' ListArgDef { (:) $1 $3 }


ArgDef :: { ArgDef }
ArgDef : Type Ident { JustArgDef $1 $2 } 


ListConstOrVar :: { [ConstOrVar] }
ListConstOrVar : {- empty -} { [] } 
  | ListConstOrVar ConstOrVar ';' { flip (:) $1 $2 }


ConstOrVar :: { ConstOrVar }
ConstOrVar : ConstDef { ConstDefListItem $1 } 
  | VarDef { VarDefListItem $1 }


Body :: { Body }
Body : '{' ListConstOrVar ListStmt '}' { JustBody (reverse $2) (reverse $3) } 


ListDef :: { [Def] }
ListDef : {- empty -} { [] } 
  | ListDef Def { flip (:) $1 $2 }


Def :: { Def }
Def : ConstDef ';' { DefConstDef $1 } 
  | VarDef ';' { VarDefDef $1 }
  | Type Ident '(' ListArgDef ')' Body { FunDef $1 $2 $4 $6 }
  | 'procedure' Ident '(' ListArgDef ')' Body { ProcDef $2 $4 $6 }
  | 'operator' Ident '(' ListArgDef ')' Body { OperatorDef $2 $4 $6 }
  | 'qufunct' 'operator' Ident '(' ListArgDef ')' Body { QufunctOperatorDef $3 $5 $7 }
  | 'cond' 'operator' Ident '(' ListArgDef ')' Body { CondOperatorDef $3 $5 $7 }
  | 'qufunct' Ident '(' ListArgDef ')' Body { QufunctDef $2 $4 $6 }
  | 'cond' 'qufunct' Ident '(' ListArgDef ')' Body { CondQufunctDef $3 $5 $7 }
  | 'extern' 'operator' Ident '(' ListArgDef ')' ';' { ExternOpDef $3 $5 }
  | 'extern' 'qufunct' Ident '(' ListArgDef ')' ';' { ExternQufunctDef $3 $5 }
  | 'extern' 'cond' 'operator' Ident '(' ListArgDef ')' ';' { ExternCondOpDef $4 $6 }
  | 'extern' 'cond' 'qufunct' Ident '(' ListArgDef ')' ';' { ExternCondQufunctDef $4 $6 }


Block :: { Block }
Block : '{' ListStmt '}' { JustBlock (reverse $2) } 



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

